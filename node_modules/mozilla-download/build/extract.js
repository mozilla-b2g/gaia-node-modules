"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

/**
 * @fileoverview Extracts firefox or b2g runtime from a compressed format.
 *
 * Options:
 *
 *   (String) product
 *   (String) filetype
 *   (String) source
 *   (String) dest
 */
module.exports = extract;

var Promise = _interopRequire(require("promise"));

var dmg = _interopRequire(require("dmg"));

var exec = require("mz/child_process").exec;

var fs = _interopRequire(require("fs"));

var ncp = require("ncp").ncp;

var tempdir = require("./temp").tempdir;

dmg.mount = Promise.denodeify(dmg.mount);
dmg.unmount = Promise.denodeify(dmg.unmount);
ncp = Promise.denodeify(ncp);

var productDirname = {
  "b2g-desktop": "b2g",
  firefox: "firefox",
  mulet: "firefox"
};
function extract(options) {
  var dest, path;
  return regeneratorRuntime.async(function extract$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        dest = options.dest;
        context$1$0.next = 3;
        return tempdir();

      case 3:
        path = context$1$0.sent;

        // Extract to temporary location.
        options.dest = path;
        context$1$0.t0 = options.filetype;
        context$1$0.next = context$1$0.t0 === "dmg" ? 8 : context$1$0.t0 === "tar.bz2" ? 11 : context$1$0.t0 === "zip" ? 14 : 17;
        break;

      case 8:
        context$1$0.next = 10;
        return extractDmg(options);

      case 10:
        return context$1$0.abrupt("break", 19);

      case 11:
        context$1$0.next = 13;
        return extractTarball(options);

      case 13:
        return context$1$0.abrupt("break", 19);

      case 14:
        context$1$0.next = 16;
        return extractZipball(options);

      case 16:
        return context$1$0.abrupt("break", 19);

      case 17:
        // Default to no extraction if we don't understand filetype.
        options.dest = dest;
        return context$1$0.abrupt("break", 19);

      case 19:
        context$1$0.next = 21;
        return ncp(options.dest, dest);

      case 21:
      case "end":
        return context$1$0.stop();
    }
  }, null, this);
}

function extractDmg(options) {
  var path, files, target, source, dest;
  return regeneratorRuntime.async(function extractDmg$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return dmg.mount(options.source);

      case 2:
        path = context$1$0.sent;
        files = fs.readdirSync(path);
        target = files.find(function (file) {
          return /\.app/.test(file);
        });
        source = path + "/" + target;
        dest = options.dest + "/" + productDirname[options.product];

        fs.mkdirSync(dest);
        context$1$0.next = 10;
        return ncp(source, dest);

      case 10:
        context$1$0.next = 12;
        return dmg.unmount(path);

      case 12:
      case "end":
        return context$1$0.stop();
    }
  }, null, this);
}

function extractTarball(options) {
  return exec(["tar", "-xf", options.source, "-C", options.dest].join(" "));
}

function extractZipball(options) {
  return exec(["unzip", options.source, "-d", options.dest].join(" "));
}

// Copy to destination.
//# sourceMappingURL=extract.js.map
var EventEmitter = require('events').EventEmitter;
var Promise = require('promise');
var util = require('util');
var merge = require('deepmerge');
var Dispatcher = require('../dispatcher');
var helpers = require('../helpers');
var MozDevice = require('mozdevice');
var report = require('../reporter');

/**
 * Base suite runner. Functionality which is common to all runners should be
 * accessible here
 * @param {{
 *   runs: Number,
 *   timeout: Number,
 *   retries: Number,
 *   preventDispatching: Boolean,
 *   emulator: Boolean
 * }} options
 * @constructor
 */
var Phase = function(options) {
  EventEmitter.call(this);

  this.runs = [];
  this.results = [];
  this.time = Date.now();
  this.options = merge({
    timeout: options.emulator ? 150 * 1000 : 60 * 1000,
    retries: 1,
    runs: 1
  }, options);

  this.resetTimeout();
};

util.inherits(Phase, EventEmitter);

Phase.prototype.GRID_ORIGIN_Y = 110;

/**
 * Emit an error if a test run times out
 */
Phase.prototype.timeoutError = function() {
  this.emit('error', new Error('Test timeout exceeded ' +
    this.options.timeout + 'ms'));
};

/**
 * Halt handling of a test run timeout
 */
Phase.prototype.stopTimeout = function() {
  if (this.timeout) {
    clearTimeout(this.timeout);
  }
};

/**
 * Restart the timeout timer and optionally specify a function to run on timeout
 * @param {function} [handler]
 */
Phase.prototype.resetTimeout = function(handler) {
  var runner = this;

  this.stopTimeout();
  this.timeout = setTimeout(handler || function() {
    runner.timeoutError();
  }, this.options.timeout);
};

/**
 * Store any entries generated by parsers of a given <eventType>
 * @param {string} eventType
 */
Phase.prototype.capture = function(eventType) {
  var runner = this;
  this.dispatcher.on(eventType, function(entry) {
    runner.results.push(entry);
  });
};

/**
 * Register a parser to be able to handle incoming log messages
 * @param {function} parser
 */
Phase.prototype.registerParser = function(parser) {
  this.dispatcher.registerParser(parser);
};

/**
 * Report time-series data
 * @param {object} data
 * @returns {Promise}
 */
Phase.prototype.report = report;

/**
 * Read an manifest.webapp file as an object
 * @param {string} path
 * @returns {object}
 */
Phase.prototype.requireManifest = function(path) {
  return helpers.requireJSON(path);
};

/**
 * Resolve when a device is ready for user interaction, e.g. tapping, swiping
 * @returns {Promise}
 */
Phase.prototype.getDevice = function() {
  var runner = this;

  if (this.device) {
    return Promise.resolve(this.device);
  }

  return new Promise(function(resolve, reject) {
    MozDevice(function(err, device) {
      if (err) {
        return runner.emit('error', err);
      }

      runner.device = device;

      // Allow specific runners to handle their own Dispatcher set up
      if (!runner.options.preventDispatching) {
        device.log.start();
        runner.dispatcher = new Dispatcher(device);
      }

      resolve(device);
    });
  });
};

/**
 * Attempt to perform a test run
 * @returns {Promise}
 */
Phase.prototype.tryRun = function() {
  var runner = this;

  return new Promise(function(resolve, reject) {
    runner.resetTimeout(function() {
      reject(new Error('timeout'));
    });

    runner
      .testRun()
      .then(resolve, reject);
  });
};

/**
 * Handler to be invoked when the current run is completed and ready for another
 * run or end of suite. Continuation is passed to the test itself for next
 * determination.
 */
Phase.prototype.next = function() {
  var runner = this;
  var rejectError = function(err) {
    runner.emit('error', err);
  };

  this.stopTimeout();
  console.log('[Test] Run %d complete', this.currentRun);

  this.runs.push(this.results);

  if (this.currentRun < this.options.runs) {
    // If we have more runs to do, notify the tester that the current run has
    // completed and pass a function which will start the next run...
    this.currentRun++;
    this.emit('run', function() {
      runner.handleRun()
        .then(function() {
          runner.test();
        }, rejectError);
    });
  } else {
    // ...otherwise notify the tester that the current run has completed and
    // pass a function which will end the test suite
    this.emit('run', function() {
      runner.handleRun()
        .then(function() {
          runner.emit('end');
          runner.removeAllListeners();
          runner.dispatcher.end();
        }, rejectError);
    });
  }
};

/**
 * Handle a test run failure by attempting any retries or notifying the test
 * runner of the failure
 * @param err
 */
Phase.prototype.fail = function(err) {
  var runner = this;

  this.stopTimeout();

  if (err.message && err.message === 'timeout') {
    if (this.currentTry <= this.options.retries) {
      console.log('[Test] Run %d timed out, retry attempt %d',
        this.currentRun, this.currentTry);
      this.currentTry++;

      // reset the timer and any potentially erroneous results
      this.resetTimeout();
      this.results = [];

      this.device.log
        .clear()
        .then(function() {
          return runner.retry();
        })
        .then(function() {
          return runner.tryRun();
        })
        .then(function() {
          runner.next();
        }, function(err) {
          runner.fail(err);
        });
    } else {
      this.timeoutError();
    }
  } else {
    runner.emit('error', err);
  }
};

/**
 * Start a single test run
 */
Phase.prototype.test = function() {
  var runner = this;

  console.log('[Test] Starting run %d', this.currentRun);

  this.results = [];

  this
    .tryRun()
    .then(function() {
      runner.next();
    }, function(err) {
      runner.fail(err);
    });
};

/**
 * There is a bug on the flame that causes it to stop responding to injected
 * touch events after a B2G restart. Swiping on the screen for some reason
 * jump-starts the responsiveness. Swipe with a downward motion on the
 * homescreen since we're at the top anyway and this won't move anywhere
 * @returns {Promise}
 */
Phase.prototype.swipeHack = function() {
  var x = this.device.config.dimensions[0] / 2;
  var startY = 250;
  var endY = 350;
  var steps = 10;
  var duration = this.device.touchFrequency * steps;

  return this.device.input.drag(x, startY, x, endY, steps, duration);
};

/**
 * Start the suite by passing execution back to the runner for event binding and
 * test notifications
 */
Phase.prototype.start = function() {
  var runner = this;

  this.currentRun = 1;
  this.currentTry = 1;

  // Force async execution to allow binding of events before test starts
  setTimeout(function() {
    runner.emit('ready');
    runner.test();
  });
};

module.exports = Phase;